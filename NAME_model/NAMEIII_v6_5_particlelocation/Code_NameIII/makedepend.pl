#!/use/bin/perl
####################################################################
#
#  Generate Dependencies for Name III project. 
#
####################################################################
#
#
#  The code reads a list of project source filenames from a file 
#  (which should be generated by make) and 
#  then traces dependencies between these source files by 
#  scanning the USE and MODULE statements. It writes the results 
#  to in a format which can be included in the Makefile.
#  If the MODULE string is defined in file mod_module2.F90 and
#  the MODULE number is defined in the file mod_module3.F90 and
#  MODULE mod1 in file mod_module1.F90 USEs both string and number,
#  this file will have the folowing form:
#
#  mod_module1.o: \
#    mod_module2.o \
#    mod_module3.o
#
####################################################################

# Declare subroutines (see end of this script)
sub AppendZeros;

# If verbose is 1, print detailled log, if it is 0, don't print anything
my $verbose=0;
my $starttime=time;

if ($verbose) {
  print "\nCreating Dependencies...\n\n";
}

# File with list of source files for the project. This file 
# should be written by the Makefile
my $SourceFilename='Makefile_sources.tmp';

# Outputfile for dependencies. This file should later by included
# in the Makefile
my $DepFilename='Makefile_dependencies';

# Read names of sources in project and store them in an array
open SOURCEFILES, "<$SourceFilename";
my $line=<SOURCEFILES>;
chomp $line;
my @SourceFilenames = split(/ /,$line);
close SOURCEFILES;

if ($verbose) {
  print "Project Source files:\n";
  for (@SourceFilenames) {
    print;
    print "\n";
  }
  print "\n";
}

# For each file, identify which modules it contains and
# create a hash of the form <module> => <filename> 

for my $file (@SourceFilenames) {
  my @GrepResults;
  open INFILE, $file;
  for $line (<INFILE>) {
    chomp $line;
    if ($line =~ /[Mm][Oo][Dd][Uu][Ll][Ee]/) {
      push(@GrepResults,$line);
    }
  }
  close INFILE;
  chomp @GrepResults;
  for (@GrepResults) {
    if ($_ =~ /^ *module +(\w+)\b/i) {
	  my $module = $1;
	  $ModuleHash{$module} = $file;
	}
  }
}

if ($verbose) { 
  print "Module Files:\n";
  for my $key (keys %ModuleHash) {
    print "module \"$key\" is defined in $ModuleHash{$key}\n";
  }
  print "\n";
}

# Get current time and date

my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);

$sec = AppendZeros($sec,2);
$min = AppendZeros($min,2);
$hour = AppendZeros($hour,2);

$mday = AppendZeros($mday,2);
$mon = AppendZeros($mon,2);
$year += 1900;

# Now, scan source files and check which other source files they
# depend on. This is decided by looking at the USE statement and
# identifying the correct module file.

open DEPFILE, ">$DepFilename";
print DEPFILE "# Makefile Dependencies for Name III\n";
print DEPFILE "# File automatically generated by $0\n";
print DEPFILE "# Timestamp $hour:$min:${sec}h $mday/$mon/$year\n\n";

if ($verbose) {
  print "Dependencies:\n";
}

for my $file (@SourceFilenames) {
  my @GrepResults;
  open INFILE, $file;
  for $line (<INFILE>) {
    chomp $line;
    if ($line =~ /[Uu][Ss][Ee]/) {
      push(@GrepResults,$line);
    }
  }
  close INFILE;
  chomp @GrepResults;
  delete @UseHash{keys %UseHash};
  for (@GrepResults) {
    if ($_ =~ /^ *use +(\w+)\b/i) {
	  $module = $1;
# Make sure we do not include Modules that are contained in the
# file itself
      my $modulefile = $ModuleHash{$module};
	    if (($modulefile ne $file) and ($modulefile)) {
   	    $UseHash{$module} = $modulefile;
  	  }
	  }
  }
  
# number of keys. Only write a dependency if this is nonzero
  my $nkeys = (keys %UseHash);
  if ($nkeys > 0) {
    $source = $file;
	  $source =~ s/\.F90$/.o/;
	  $source =~ s/\.f90$/.o/;
    if ($verbose) {
      print "$source depends on: ";
    }

    print DEPFILE "$source:";
	  for my $key (keys %UseHash) {
	    $target = $UseHash{$key};
	    $target =~ s/\.F90$/.o/;
	    $target =~ s/\.f90$/.o/;
	    print DEPFILE "\\\n  $target";
	    if ($verbose) {
	      print "$target ";
	    }
    }
	  if ($verbose) {
      print "\n\n";
  	}
	  print DEPFILE "\n";
  }
  print DEPFILE "\n";
}

close DEPFILE;

my $runtime=time-$starttime;

if ($verbose) {
  print "\n... Done [${runtime}s]\n";
}

####################################################################
#
# Append leading zeros to a number until it has a given length $n
#
####################################################################

sub AppendZeros {
  my ($value,$n) = @_;
  while (length $value < $n) {
    $value = '0'.$value;
  }
  return $value;
}

