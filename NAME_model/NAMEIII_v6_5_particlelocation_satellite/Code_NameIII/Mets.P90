! Module: Mets Module

Module MetsModule

! This module provides code to make all met modules look identical. 

! Module overview
! ---------------

! $$

! Certain pieces of code need to be repeated for some or all met modules. This code repetition is achieved by 
! prepreocessing Mets.P90 with Preprocessor.exe to produce Mets.F90. Whenever a new met module is added, 
! appropriate $UseBlock directives should be added for use by Preprocessor.exe.

! Module use
! ----------

! $$

! Module call tree
! ----------------

!-------------------------------------------------------------------------------------------------------------

Use ServiceModule
Use CommonMetModule

$BeginBlock Use
Use ????MetModule
$EndBlock Use
$UseBlock Use ???? Prototype
$UseBlock Use ???? SingleSite 
$UseBlock Use ???? NWP 
$UseBlock Use ???? Radar 
$UseBlock Use ???? Ancillary

!-------------------------------------------------------------------------------------------------------------

Implicit None

!-------------------------------------------------------------------------------------------------------------

Private
Public  :: CommonMetP_          ! A pointer to an instance of the type CommonMet_.
Public  :: Mets_                ! A collection of met module instance states.  
Public  :: InitMets             ! Initialises a collection of met module instance 
                                ! states.

$BeginBlock AddMet
Public  :: Add????Met           ! Adds the state of a ???? met module instance to a 
                                ! collection of met module instance states.
$EndBlock AddMet
$UseBlock AddMet ???? Prototype
$UseBlock AddMet ???? SingleSite 
$UseBlock AddMet ???? NWP 
$UseBlock AddMet ???? Radar
$UseBlock AddMet ???? Ancillary
 
Public  :: FindMetIndex         ! Finds the indices of a met module and a met module 
                                ! instance.
Public  :: SetUpCoordsEtc_Mets  ! Sets up Coords and Grids by adding any extra coords 
                                ! and grids which Mets wants to define.
Public  :: SetUpMets_CoordsEtc  ! Sets up Mets using information from EtaDefns, Coords 
                                ! and Grids.
Public  :: SetUpMets_iCoordsEtc ! Sets up indices in the met module instances for 
                                ! referring coord systems and grids.  
Public  :: MetList              ! Returns a list of the met module instances.
Public  :: MetValid             ! Returns information on the validity of a met module 
                                ! instance.
Public  :: UpdateMets           ! Updates the state of the met module instances.
Public  :: UpdateMet            ! Updates the state of a met module instance.
Public  :: ResetMets            ! Resets the state of the met module instances for a
                                ! new realisation.

!-------------------------------------------------------------------------------------------------------------

! The following items are items from the various met modules which need to be made 
! available by the mets module.

$BeginBlock Met_
Public  :: ????Met_    ! Information describing the state of an instance of the ???? 
                       ! met module.
$EndBlock Met_
$UseBlock Met_ ???? Prototype
$UseBlock Met_ ???? SingleSite 
$UseBlock Met_ ???? NWP 
$UseBlock Met_ ???? Radar
$UseBlock Met_ ???? Ancillary 

$BeginBlock InitMet
Public  :: Init????Met ! Initialises an instance of ????Met_. 
$EndBlock InitMet
$UseBlock InitMet ???? Prototype
$UseBlock InitMet ???? SingleSite 
$UseBlock InitMet ???? NWP 
$UseBlock InitMet ???? Radar
$UseBlock InitMet ???? Ancillary 

!-------------------------------------------------------------------------------------------------------------

Type :: CommonMetP_ ! A pointer to an instance of the type CommonMet_.
  Type(CommonMet_), Pointer :: P ! Pointer to an instance of the type CommonMet_. 
End Type CommonMetP_

!-------------------------------------------------------------------------------------------------------------

Type :: Mets_ ! A collection of met module instance states.
  Integer           :: nMetMods 
  Integer           :: nMets(MaxMetMods)   
  Type(CommonMetP_) :: C(MaxMetMods, MaxMetsPerMod) 

$ BeginBlock Mets_
  Integer        :: n????Mets 
  Type(????Met_) :: ????Mets(Max????Mets) 
$ EndBlock Mets_
$ UseBlock Mets_ ???? Prototype
$ UseBlock Mets_ ???? SingleSite
$ UseBlock Mets_ ???? NWP
$ UseBlock Mets_ ???? Radar
$ UseBlock Mets_ ???? Ancillary

  ! nMetMods  :: Number of met modules.
  ! nMets     :: Number of instances of each met module. 
  ! C         :: Pointers to the common parts of the met module instance states.
  ! n????Mets :: Number of instances of the ???? met module.    
  ! ????Mets  :: States of all instances of the ???? met module.
End Type Mets_

!-------------------------------------------------------------------------------------------------------------

Contains

!-------------------------------------------------------------------------------------------------------------

Function InitMets() Result(Mets)
! Initialises a collection of met module instance states.

  Implicit None
  ! Function result:
  Type(Mets_) :: Mets ! The initialised collection of met module instance states.

  Mets%nMetMods = 0
  
$ BeginBlock InitMets   
  Mets%n????Mets = 0 
$ EndBlock InitMets
$ UseBlock InitMets ???? Prototype
$ UseBlock InitMets ???? SingleSite
$ UseBlock InitMets ???? NWP
$ UseBlock InitMets ???? Radar
$ UseBlock InitMets ???? Ancillary
     
End Function InitMets

!-------------------------------------------------------------------------------------------------------------

$BeginBlock AddMet

Subroutine Add????Met(????Met, Mets)  
! Adds the state of a ???? met module instance to a collection of met module instance 
! states.

  Implicit None
  ! Argument list:
  Type(????Met_), Intent(In)            :: ????Met ! The state of the ???? met module 
                                                   ! instance. 
  Type(Mets_),    Intent(InOut), Target :: Mets    ! The collection of met module 
                                                   ! instance states.
  ! Locals:
  Integer :: i       ! Loop index.
  Integer :: j       ! Loop index.
  Integer :: iMetMod ! Index of met module to be added.
  Integer :: iMet    ! Index of met module instance to be added.

  ! Calculate iMetMod and, if necessary, check for too many met modules, update 
  ! Mets%nMetMods and initialise Mets%nMets(iMetMod).
  If (Mets%n????Mets == 0) Then
    If (Mets%nMetMods == MaxMetMods) Then
      Call Message('FATAL ERROR in Add????Met: Too many met modules', 3)
    End If
    iMetMod             = Mets%nMetMods + 1
    Mets%nMetMods       = iMetMod
    Mets%nMets(iMetMod) = 0
  Else
    iMetMod = Mets%????Mets(1)%C%iMetMod 
  End If 

  ! Check for too many met module instances of this type and for duplicate names.
  If (Mets%nMets(iMetMod) == Max????Mets) Then
    Call Message(                                          &
           'FATAL ERROR in Add????Met: '                // &
           'Too many instances of the ???? met module',    &
           3                                               &
         )
  End If
  Do i = 1, Mets%nMetMods
  Do j = 1, Mets%nMets(i)
    If (Mets%C(i ,j)%P%MetName .CIEq. ????Met%C%MetName) Then
      Call Message(                                                               &
             'FATAL ERROR in Add????Met: a met module instance with the same ' // &
             'name already exists',                                               &
             3                                                                    &
           )
    End If    
  End Do
  End Do

  ! Calculate iMet.
  iMet = Mets%nMets(iMetMod) + 1

  ! Add met module instance.
  Mets%nMets(iMetMod)           =  iMet                           
  Mets%n????Mets                =  iMet
  Mets%????Mets(iMet)           =  ????Met
  Mets%????Mets(iMet)%C%iMetMod =  iMetMod
  Mets%????Mets(iMet)%C%iMet    =  iMet
  Mets%C(iMetMod, iMet)%P       => Mets%????Mets(iMet)%C                

  ! Check TValid is the right type of time.
  If (IsTimeInterval(Mets%C(iMetMod, iMet)%P%TValid)) Then
    Call Message('UNEXPECTED FATAL ERROR in Add????Met', 4)
  End If

  ! Check consistency of FixedMet between met module instances.
  If (Mets%C(1, 1)%P%FixedMet .neqv. Mets%C(iMetMod, iMet)%P%FixedMet) Then
    Call Message('UNEXPECTED FATAL ERROR in Add????Flow', 4)
  End If

End Subroutine Add????Met

$EndBlock AddMet
$UseBlock AddMet ???? Prototype
$UseBlock AddMet ???? SingleSite
$UseBlock AddMet ???? NWP
$UseBlock AddMet ???? Radar
$UseBlock AddMet ???? Ancillary

!-------------------------------------------------------------------------------------------------------------

Subroutine FindMetIndex(MetModName, MetName, Mets, iMetMod, iMet)
! Finds the indices of a met module and a met module instance.

  Implicit None
  ! Argument list:
  Character(*), Intent(In)  :: MetModName ! Met module name.
  Character(*), Intent(In)  :: MetName    ! Met module instance name.
  Type(Mets_),  Intent(In)  :: Mets       ! Collection of met module instance states.
  Integer,      Intent(Out) :: iMetMod    ! Met module index.
  Integer,      Intent(Out) :: iMet       ! Met module instance index.
  ! Locals:
  Integer :: i ! Loop index.

  iMetMod = 0
  Do i = 1, Mets%nMetMods            
    If (Mets%nMets(i) > 0) Then
      If (MetModName .CIEq. Mets%C(i, 1)%P%MetModName) Then
        iMetMod = i
        Exit
      End If
    End If
  End Do
  If (iMetMod == 0) Then
    Call Message('FATAL ERROR in FindMetIndex: met module not found', 3)
  End If

  iMet = 0
  Do i = 1, Mets%nMets(iMetMod)            
    If (MetName .CIEq. Mets%C(iMetMod, i)%P%MetName) Then
      iMet = i
      Exit
    End If
  End Do
  If (iMet == 0) Then
    Call Message('FATAL ERROR in FindMetIndex: met module instance not found', 3)
  End If

End Subroutine FindMetIndex

!-------------------------------------------------------------------------------------------------------------

Subroutine SetUpCoordsEtc_Mets(Mets, Coords, Grids)
! Sets up Coords and Grids by adding any extra coords and grids which Mets wants to
! define.

  Implicit None
  ! Argument list:
  Type(Mets_),   Intent(In)    :: Mets   ! Collection of met module instance states. 
  Type(Coords_), Intent(InOut) :: Coords ! Collection of coord systems.
  Type(Grids_),  Intent(InOut) :: Grids  ! Collection of grids.
  ! Locals:
  Integer :: iMetMod ! Met module index.
  Integer :: iMet    ! Met module instance index.

  Do iMetMod = 1, Mets%nMetMods
  Do iMet    = 1, Mets%nMets(iMetMod)  
              
    If (.false.) Then

$   BeginBlock SetUpCoordsEtc_Met
    Else If (                               &
      Mets%n????Mets /= 0 .and.             &
      iMetMod == Mets%????Mets(1)%C%iMetMod &
    ) Then 
       
      Call SetUpCoordsEtc_????Met(Mets%????Mets(iMet), Coords, Grids)  

$   EndBlock SetUpCoordsEtc_Met
$   UseBlock SetUpCoordsEtc_Met ???? SingleSite
$   UseBlock SetUpCoordsEtc_Met ???? NWP
$   UseBlock SetUpCoordsEtc_Met ???? Ancillary

    ! Check met module present.
    Else If (.not. MetPresent(iMetMod, iMet, Mets)) Then
      Call Message('UNEXPECTED FATAL ERROR in SetUpCoordsEtc_Mets: met module not found', 4)
    End If

  End Do   
  End Do 

End Subroutine SetUpCoordsEtc_Mets

!-------------------------------------------------------------------------------------------------------------

Subroutine SetUpMets_CoordsEtc(EtaDefns, Coords, Grids, MetEnsembleSize, Mets)
! Sets up Mets using information from EtaDefns, Coords and Grids.

  Implicit None
  ! Argument list:
  Type(EtaDefns_), Intent(In)    :: EtaDefns        ! Collection of eta definitions.
  Type(Coords_),   Intent(In)    :: Coords          ! Collection of coord systems.
  Type(Grids_),    Intent(In)    :: Grids           ! Collection of grids.
  Integer,         Intent(In)    :: MetEnsembleSize ! Size of the met ensemble (i.e. number of met
                                                    ! realisations).
  Type(Mets_),     Intent(InOut) :: Mets            ! Collection of met module instance states.
  ! Locals:
  Integer :: iMetMod ! Met module index.
  Integer :: iMet    ! Met module instance index.

  Do iMetMod = 1, Mets%nMetMods
  Do iMet    = 1, Mets%nMets(iMetMod)  
              
    If (.false.) Then

$   BeginBlock SetUpMet_CoordsEtc
    Else If (                               &
      Mets%n????Mets /= 0 .and.             &
      iMetMod == Mets%????Mets(1)%C%iMetMod &
    ) Then    

      Call SetUp????Met_CoordsEtc(EtaDefns, Coords, Grids, MetEnsembleSize, Mets%????Mets(iMet))  

$   EndBlock SetUpMet_CoordsEtc
$   UseBlock SetUpMet_CoordsEtc ???? SingleSite
$   UseBlock SetUpMet_CoordsEtc ???? NWP
$   UseBlock SetUpMet_CoordsEtc ???? Radar
$   UseBlock SetUpMet_CoordsEtc ???? Ancillary

    ! Check met module present.
    Else If (.not. MetPresent(iMetMod, iMet, Mets)) Then
      Call Message('UNEXPECTED FATAL ERROR in SetUpMets_CoordsEtc: met module not found', 4)
    End If

  End Do   
  End Do 

End Subroutine SetUpMets_CoordsEtc

!-------------------------------------------------------------------------------------------------------------

Subroutine SetUpMets_iCoordsEtc(Coords, Grids, Mets)
! Sets up indices in the met module instances for referring coord systems and grids.  

  Implicit None
  ! Argument list:
  Type(Coords_), Intent(In)    :: Coords ! Collection of coord systems.
  Type(Grids_),  Intent(In)    :: Grids  ! Collection of grids.
  Type(Mets_),   Intent(InOut) :: Mets   ! Collection of met module instance states.
  ! Locals:
  Type(CommonMet_), Pointer :: CommonMet ! Abreviation for the part of the met state common to all met 
                                         ! modules.
  Integer                   :: iMetMod   ! Met module index.
  Integer                   :: iMet      ! Met module instance index.
  Integer                   :: i         ! Loop Index.

  Do iMetMod = 1, Mets%nMetMods
  Do iMet    = 1, Mets%nMets(iMetMod)  
              
    CommonMet => Mets%C(iMetMod, iMet)%P

    Do i = 1, CommonMet%nHCoords  
      CommonMet%iHCoords(i) = FindHCoordIndex(CommonMet%HCoordNames(i), Coords)
    End Do

    Do i = 1, CommonMet%nZCoords 
      CommonMet%iZCoords(i) = FindZCoordIndex(CommonMet%ZCoordNames(i), Coords) 
    End Do

    Do i = 1, CommonMet%nHGrids  
      CommonMet%iHGrids(i) = FindHGridIndex(CommonMet%HGridNames(i), Grids)
    End Do

    Do i = 1, CommonMet%nZGrids 
      CommonMet%iZGrids(i) = FindZGridIndex(CommonMet%ZGridNames(i), Grids) 
    End Do

  End Do   
  End Do 

End Subroutine SetUpMets_iCoordsEtc

!-------------------------------------------------------------------------------------------------------------

Subroutine MetList(Mets, nMets, MetNames)
! Returns a list of the met module instances.

  Implicit None
  ! Argument list:
  Type(Mets_),              Intent(In)  :: Mets
  Integer,                  Intent(Out) :: nMets
  Character(MaxCharLength), Intent(Out) :: MetNames(MaxMets)
  ! Mets     :: Collection of met module instance states.
  ! nMets    :: Number of the met module instance states.
  ! MetNames :: Names of the met module instance states.
  ! Locals:
  Integer :: iMetMod ! Met module index.
  Integer :: iMet    ! Met module instance index.

  nMets = 0
  Do iMetMod = 1, Mets%nMetMods
  Do iMet    = 1, Mets%nMets(iMetMod)
    nMets = nMets + 1
    MetNames(nMets) = Trim(Mets%C(iMetMod, iMet)%P%MetModName) // &
                      '.'                                      // &
                      Trim(Mets%C(iMetMod, iMet)%P%MetName)
  End Do
  End Do


End Subroutine MetList

!-------------------------------------------------------------------------------------------------------------

Function MetPresent(iMetMod, iMet, Mets)
! Checks whether a met module instance with given indices is present.

  Implicit None
  ! Argument list:
  Integer,     Intent(In) :: iMetMod ! Met module index.
  Integer,     Intent(In) :: iMet    ! Met module instance index.
  Type(Mets_), Intent(In) :: Mets    ! Collection of met module instance states.
  ! Function result:
  Logical :: MetPresent ! Indicates whether the met module instance is present.

  MetPresent = .false.

  If (.false.) Then

$ BeginBlock MetPresent
  Else If (                               &
    Mets%n????Mets /= 0 .and.             &
    iMetMod == Mets%????Mets(1)%C%iMetMod &
  ) Then
      
    MetPresent = .true.

$ EndBlock MetPresent
$ UseBlock MetPresent ???? Prototype
$ UseBlock MetPresent ???? SingleSite
$ UseBlock MetPresent ???? NWP
$ UseBlock MetPresent ???? Radar
$ UseBlock MetPresent ???? Ancillary

  End If

End Function MetPresent

!-------------------------------------------------------------------------------------------------------------

Subroutine MetValid(Mets, iMetMod, iMet, Time, Valid, TValid, ValidAttribs)
! Returns information on the validity of a met module instance.

  Implicit None
  ! Argument list:
  Type(Mets_), Intent(In)            :: Mets
  Integer,     Intent(In)            :: iMetMod
  Integer,     Intent(In)            :: iMet
  Type(Time_), Intent(In)            :: Time
  Logical,     Intent(Out)           :: Valid
  Type(Time_), Intent(Out)           :: TValid
  Logical,     Intent(Out), Optional :: ValidAttribs(MaxMetAttribs)
  ! Mets         :: Collection of met module instance states.
  ! iMetMod      :: Met module index.
  ! iMet         :: Met module instance index.
  ! Time         :: Current time in non-fixed met cases and current time or the time of the met in fixed met 
  !                 cases.
  ! Valid        :: Indicates the met module instance is known to be valid at the current time.
  ! TValid       :: Earliest time the validity of the met module instance might change. 
  ! ValidAttribs ::
  ! Locals:
  Type(CommonMet_), Pointer :: CommonMet ! Abreviation for the part of met state 
                                         ! common to all met modules. 

  CommonMet => Mets%C(iMetMod, iMet)%P

# ifdef ExtraChecks
    If (                            &
      iMetMod > Mets%nMetMods .or.  &
      iMet    > Mets%nMets(iMetMod) &
    ) Then
      Call Message('UNEXPECTED FATAL ERROR in MetValid', 4)
    End If
    If (IsTimeInterval(Time)) Then
      Call Message('UNEXPECTED FATAL ERROR in MetValid', 4)
    End If
# endif

  If (Present(ValidAttribs)) Then
    ValidAttribs(:) = CommonMet%ValidAttribs(:) .and. Time < CommonMet%TValid
  End If
  Valid  = CommonMet%Valid .and. Time < CommonMet%TValid
  TValid = TMax(CommonMet%TValid, Time)

End Subroutine MetValid

!-------------------------------------------------------------------------------------------------------------

Subroutine UpdateMets(                      &
             Coords, Grids,                 &
             SameResultsWithUpdateOnDemand, &
             iCase, iMetCase,               &
             MetTime,                       &
             OverallTValid,                 &
             Mets,                          &
             Units                          &
           )
! Updates the state of the met module instances.


  Use OpenMPModule, only : LookaheadFileReadCompleteWait &
                          ,LookaheadFileReadRequest      &
                          ,OpenMPOpts_

  Implicit None
  
  ! Argument list:
  Type(Coords_), Intent(In)    :: Coords
  Type(Grids_),  Intent(In)    :: Grids
  Logical,       Intent(In)    :: SameResultsWithUpdateOnDemand
  Integer,       Intent(In)    :: iCase
  Integer,       Intent(In)    :: iMetCase
  Type(Time_),   Intent(In)    :: MetTime
  Type(Time_),   Intent(InOut) :: OverallTValid
  Type(Mets_),   Intent(InOut) :: Mets
  Type(Units_),  Intent(InOut) :: Units
  ! Coords                        :: Collection of coord systems.
  ! Grids                         :: Collection of grids.
  ! SameResultsWithUpdateOnDemand :: Indicates results should be made the same whether the met and flow module 
  !                                  instances use update-on-demand or update-at-once (so it should really be 
  !                                  called SameResultsWithOrWithoutUpdateOnDemand).
  ! iCase                         :: Number of case.
  ! iMetCase                      :: Number of the met realisation in the met ensemble.
  ! MetTime                       :: Time for which the met module instances are to be updated (this must be 
  !                                  the current time unless we have a fixed met case, in which case it must 
  !                                  be the time of the fixed met).
  ! OverallTValid                 :: Earliest time that the validity of any of the met module instances might 
  !                                  change, assuming all the instances which have been prepared for 
  !                                  update-on-demand are updated now. The value is that determined at the end 
  !                                  of this routine (the actual time may be later).
  ! Mets                          :: Collection of met module instance states.
  ! Units                         :: Collection of information on input/output unit numbers.
  ! Locals:
  Type(CommonMet_), Pointer :: CommonMet
  Integer                   :: iMetMod
  Integer                   :: iMet
  Type(Time_)               :: TValid
  Logical                   :: UpdateNow
  Logical                   :: ParallelMetRead
  ! CommonMet :: Abbreviation for the common part of the met module instance.
  ! iMetMod   :: Met module index.
  ! iMet      :: Met module instance index.
  ! TValid    :: Earliest time that the validity (overall or for any single attribute) of the met module 
  !              instance might change, assuming the met module instance is updated now. The value is that 
  !              determined at the end of PrepareForUpdateMet (the actual time may be later).
  ! UpdateNow :: Indicates the met module instance must be updated now (even if update-on-demand is 
  !              specified). If set, the value of TValid is not reliable.
  ! ParallelMetRead :: specifies whether (at least one) NWPMet module is updated by the parallel IO
  !                    thread

  ! Go through all Met modules and check whether one of them has OpenMPOpts%ParallelMetRead == .true.
  
  ParallelMetRead = .false.
  
  Do iMet = 1, Mets%nNWPMets
    ParallelMetRead = ParallelMetRead .or. Mets%NWPMets(iMet)%OpenMPOpts%ParallelMetRead
    ! Check if the ParallelMetRead flag is consistent between all NWPMet instances
    ! $$ At some point we might allow this flag to differ to only prefect selected NWPMet
    if ((iMet > 1) .and. (Mets%NWPMets(iMet)%OpenMPOpts%ParallelMetRead .neqv. ParallelMetRead)) Then
      Call Message('ERROR: The flag ParallelMetRead has to be identical for all NWPMet module instances',4)
    End If
  End Do
  
  ! Wait until any lookahead reads have completed before starting our Met Reads 
  If (ParallelMetRead) Then
    Call LookaheadFileReadCompleteWait()
  End If
  
  ! Loop over met module instances.
  Do iMetMod = 1, Mets%nMetMods
  Do iMet    = 1, Mets%nMets(iMetMod)

    CommonMet => Mets%C(iMetMod, iMet)%P

    ! Check MetTime is the right type of time and is finite.
    If (iMetMod == 1 .and. iMet == 1) Then
      If (IsTimeInterval(MetTime)) Then
        Call Message('UNEXPECTED FATAL ERROR in UpdateMets', 4)
      End If
      If (IsInfFuture(MetTime) .or. IsInfPast(MetTime)) Then
        Call Message('UNEXPECTED FATAL ERROR in UpdateMets', 4)
      End If
    End If

    ! Is the validity of the met module instance improvable? 
    If (MetTime >= CommonMet%TValid) Then 

      ! Prepare to update met module instance.
      Call PrepareForUpdateMet( &
             Coords, Grids,     &
             iCase, iMetCase,   &
             iMetMod, iMet,     &
             MetTime,           &
             TValid, UpdateNow, &
             Mets,              &
             Units              &
           )

      If (UpdateNow) Then

        ! Try to update met module instance.
        Call UpdateMet(         &
               Coords, Grids,   &
               iCase, iMetCase, &
               iMetMod, iMet,   &
               MetTime,         &
               Mets,            &
               Units            &
             )
        ! Update OverallTValid.
        OverallTValid = TMin(OverallTValid, CommonMet%TValid)

      Else If (.not. CommonMet%UpdateOnDemand) Then

        ! Try to update met module instance.
        Call UpdateMet(         &
               Coords, Grids,   &
               iCase, iMetCase, &
               iMetMod, iMet,   &
               MetTime,         &
               Mets,            &
               Units            &
             )
        ! Update OverallTValid. For same results whether update-on-demand or update-at-once is used, update 
        ! OverallTValid using the local variable TValid for update-at-once, as would be used for 
        ! update-on-demand.
        If (.not. SameResultsWithUpdateOnDemand) Then
          OverallTValid = TMin(OverallTValid, CommonMet%TValid)
        Else
          OverallTValid = TMin(OverallTValid, TValid)
        End If

      Else

        ! Update OverallTValid.
        OverallTValid = TMin(OverallTValid, TValid)

      End If

    Else

      ! Update OverallTValid.
      OverallTValid = TMin(OverallTValid, CommonMet%TValid)

    End If

  End Do
  End Do

  ! Tell the IO Thread to prefetch any data 
  If (ParallelMetRead) Then
    Call LookaheadFileReadRequest()
  End If

End Subroutine UpdateMets

!-------------------------------------------------------------------------------------------------------------

Subroutine PrepareForUpdateMet( &
             Coords, Grids,     &
             iCase, iMetCase,   &
             iMetMod, iMet,     &
             MetTime,           &
             TValid, UpdateNow, &
             Mets,              &
             Units              &
           )
! Prepares for updating the state of a met module instance. 

  Implicit None
  ! Argument list:
  Type(Coords_), Intent(In)    :: Coords    ! Collection of coord systems.
  Type(Grids_),  Intent(In)    :: Grids     ! Collection of grids.
  Integer,       Intent(In)    :: iCase     ! Number of case.
  Integer,       Intent(In)    :: iMetCase  ! Number of the met realisation in the met ensemble.
  Integer,       Intent(In)    :: iMetMod   ! Met module index.
  Integer,       Intent(In)    :: iMet      ! Met module instance index.
  Type(Time_),   Intent(In)    :: MetTime   ! Time for which the met module instance is to be updated (this 
                                            ! must be the current time unless we have a fixed met case, in 
                                            ! which case it must be the time of the fixed met).
  Type(Time_),   Intent(Out)   :: TValid    ! Earliest time that the validity (overall or for any single 
                                            ! attribute) of the met module instance might change, assuming the 
                                            ! met module instance is updated now. The value is that determined
                                            ! at the end of this routine (the actual time may be later).  
  Logical,       Intent(Out)   :: UpdateNow ! Indicates the met module instance must be updated now (even if 
                                            ! update-on-demand is specified). If set, TValid need not be set 
                                            ! to any particular time.
  Type(Mets_),   Intent(InOut) :: Mets      ! Collection of met module instance states.
  Type(Units_),  Intent(InOut) :: Units     ! Collection of information on input/output unit numbers.
  ! Locals:
  Type(CommonMet_), Pointer :: CommonMet
  ! CommonMet :: Abbreviation for the common part of the met module instance.

  CommonMet => Mets%C(iMetMod, iMet)%P

  If (.false.) Then

$ BeginBlock PrepareForUpdateMet
  Else If (                               &
    Mets%n????Mets /= 0 .and.             &
    iMetMod == Mets%????Mets(1)%C%iMetMod &
  ) Then
      
    Call PrepareForUpdate????Met( &
           Coords, Grids,         &
           iCase, iMetCase,       &
           MetTime,               &
           TValid, UpdateNow,     &
           Mets%????Mets(iMet),   &
           Units                  &
         )  

$ EndBlock PrepareForUpdateMet
$ UseBlock PrepareForUpdateMet ???? Prototype
$ UseBlock PrepareForUpdateMet ???? SingleSite
$ UseBlock PrepareForUpdateMet ???? NWP
$ UseBlock PrepareForUpdateMet ???? Radar
$ UseBlock PrepareForUpdateMet ???? Ancillary

  Else
    Call Message('UNEXPECTED FATAL ERROR in PrepareForUpdateMet: met module not found', 4)
  End If

  ! Check TValid.
  If (.not. UpdateNow) Then

    ! Check TValid is the right type of time.
    If (IsTimeInterval(TValid)) Then
      Call Message('UNEXPECTED FATAL ERROR in PrepareForUpdateMet', 4)
    End If

    ! Check that TValid is in the future, and, for fixed met, is infinite. 
    If (TValid <= MetTime) Then
      Call Message('UNEXPECTED FATAL ERROR in PrepareForUpdateMet', 4)
    End If
    If (CommonMet%FixedMet) Then
      If (.not. IsInfFuture(TValid)) Then
        Call Message('UNEXPECTED FATAL ERROR in PrepareForUpdateMet', 4)
      End If
    End If

  End If

  ! Update DueForUpdate.
  CommonMet%DueForUpdate = .true.

End Subroutine PrepareForUpdateMet

!-------------------------------------------------------------------------------------------------------------

Subroutine UpdateMet(         &
             Coords, Grids,   &
             iCase, iMetCase, &
             iMetMod, iMet,   &
             MetTime,         &
             Mets,            &
             Units            &
           )
! Updates the state of a met module instance.

  Implicit None
  ! Argument list:
  Type(Coords_), Intent(In)    :: Coords   ! Collection of coord systems.
  Type(Grids_),  Intent(In)    :: Grids    ! Collection of grids.
  Integer,       Intent(In)    :: iCase    ! Number of case.
  Integer,       Intent(In)    :: iMetCase ! Number of the met realisation in the met ensemble.
  Integer,       Intent(In)    :: iMetMod  ! Met module index.
  Integer,       Intent(In)    :: iMet     ! Met module instance index.
  Type(Time_),   Intent(In)    :: MetTime  ! Time for which the met module instance is to be updated (this
                                           ! must be the current time unless we have a fixed met case, in 
                                           ! which case it must be the time of the fixed met).
  Type(Mets_),   Intent(InOut) :: Mets     ! Collection of met module instance states.
  Type(Units_),  Intent(InOut) :: Units    ! Collection of information on input/output unit numbers.
  ! Locals:
  Type(CommonMet_), Pointer :: CommonMet ! Abbreviation for the common part of the met module instance.

  CommonMet => Mets%C(iMetMod, iMet)%P

  If (.false.) Then

$ BeginBlock UpdateMet
  Else If (                               &
    Mets%n????Mets /= 0 .and.             &
    iMetMod == Mets%????Mets(1)%C%iMetMod &
  ) Then
      
    Call Update????Met(         &
           Coords, Grids,       &
           iCase, iMetCase,     &
           MetTime,             &
           Mets%????Mets(iMet), &
           Units                &
         )  

$ EndBlock UpdateMet
$ UseBlock UpdateMet ???? Prototype
$ UseBlock UpdateMet ???? SingleSite
$ UseBlock UpdateMet ???? NWP
$ UseBlock UpdateMet ???? Radar
$ UseBlock UpdateMet ???? Ancillary

  Else
    Call Message('UNEXPECTED FATAL ERROR in UpdateMet: met module not found', 4)
  End If

  ! Check TValid is the right type of time.
  If (IsTimeInterval(CommonMet%TValid)) Then
    Call Message('UNEXPECTED FATAL ERROR in UpdateMet', 4)
  End If

  ! Check that TValid is in the future, and, for fixed met, is infinite. 
  If (CommonMet%TValid <= MetTime) Then
    Call Message('UNEXPECTED FATAL ERROR in UpdateMet', 4)
  End If
  If (CommonMet%FixedMet) Then
    If (.not. IsInfFuture(CommonMet%TValid)) Then
      Call Message('UNEXPECTED FATAL ERROR in UpdateMet', 4)
    End If
  End If

  ! Messages for whether met update was sucessful.
  If (CommonMet%Valid) Then
    If (CommonMet%FixedMet) Then
      Call Message(                        & 
             'Met module "'             // &
             Trim(CommonMet%MetModName) // &
             '.'                        // &
             Trim(CommonMet%MetName)    // &
             '" now valid'                 &
           )
    Else
      Call Message(                                                   & 
             'Met module "'                                        // &
             Trim(CommonMet%MetModName)                            // &
             '.'                                                   // &
             Trim(CommonMet%MetName)                               // &
             '" now valid until '                                  // &
             Trim(Time2Char(CommonMet%TValid, .false., 0, .true.))    &
           )
    End If
  Else
    Call Message(                             &
           'Unable to update met module "' // &
           Trim(CommonMet%MetModName)      // &
           '.'                             // &
           Trim(CommonMet%MetName)         // &
           '"'                                &
         )
  EndIf

  ! Update DueForUpdate.
  CommonMet%DueForUpdate = .false.

End Subroutine UpdateMet

!-------------------------------------------------------------------------------------------------------------

Subroutine ResetMets(Mets)
! Resets the state of the met module instances for a new realisation.

  Implicit None
  ! Argument list:
  Type(Mets_), Intent(InOut) :: Mets ! Collection of met module instance states.
  ! Locals:
  Integer :: iMetMod ! Met module index.
  Integer :: iMet    ! Met module instance index.

  Do iMetMod = 1, Mets%nMetMods
  Do iMet    = 1, Mets%nMets(iMetMod)

    Mets%C(iMetMod, iMet)%P%Valid        = .false.
    Mets%C(iMetMod, iMet)%P%TValid       = InfPastTime()  
    Mets%C(iMetMod, iMet)%P%DueForUpdate = .false.

  End Do
  End Do

$ BeginBlock ResetMet
  Do iMet = 1, Mets%n????Mets
    Call Reset????Met(Mets%????Mets(iMet))
  End Do
$ EndBlock ResetMet
$ UseBlock ResetMet ???? SingleSite
$ UseBlock ResetMet ???? NWP
$ UseBlock ResetMet ???? Ancillary

End Subroutine ResetMets

!-------------------------------------------------------------------------------------------------------------

End Module MetsModule
