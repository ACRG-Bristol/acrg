# Copyright 2005-2007 ECMWF
#
# Licensed under the GNU Lesser General Public License which
# incorporates the terms and conditions of version 3 of the GNU
# General Public License.
# See LICENSE and gpl-3.0.txt for details.

# For grib1 -> grib2
# For now, we do simple packing...
#constant dataRepresentationTemplateNumber = 0;

# not implemented : complex packing
unsigned [2] N1;
flags[1] extendedFlag "grib1/11-2.table";

#  Undocumented use of octet 14 extededFlags
#  Taken from d2ordr.F
#         R------- only bit 1 is reserved.
#         -0------ single datum at each grid point.
#         -1------ matrix of values at each grid point.
#         --0----- no secondary bit map.
#         --1----- secondary bit map present.
#         ---0---- second order values have constant width.
#         ---1---- second order values have different widths.
#         ----0--- no general extended second order packing.
#         ----1--- general extended second order packing used.
#         -----0-- standard field ordering in section 4.
#         -----1-- boustrophedonic ordering in section 4.
#         ------00 no spatial differencing used.
#         ------01 1st-order spatial differencing used.
#         ------10 2nd-order    "         "         " .
#         ------11 3rd-order    "         "         " .

#ksec4(8)
flagbit matrixOfValues              (extendedFlag,6) = 0  : dump;
#ksec4(9)
flagbit secondaryBitmapPresent      (extendedFlag,5) = 0  : dump;
#ksec4(10)
flagbit secondOrderOfDifferentWidth (extendedFlag,4) = 0  : dump;
#ksec4(12)
flagbit generalExtended2ordr        (extendedFlag,3) = 0  : dump;
#ksec4(13)
flagbit boustrophedonicOrdering     (extendedFlag,2) = 0  : dump;
#ksec4(14)
flagbit twoOrdersOfSPD              (extendedFlag,1) = 0  : dump;
#ksec4(15)
flagbit plusOneinOrdersOfSPD        (extendedFlag,0) = 0  : dump;

alias secondaryBitmap = secondaryBitmapPresent;

unsigned [2] N2 : dump;
unsigned [2] codedNumberOfFirstOrderPackedValues : no_copy ;
unsigned [2] numberOfSecondOrderPackedValues : dump;
# used to extend
unsigned [1] extraValues=0 : hidden, edition_specific;

transient numberOfFirstOrderPackedValues=
	codedNumberOfFirstOrderPackedValues + 65536 * extraValues;

# octets 22... ???
if (generalExtended2ordr ) {
	unsigned [1] widthOfWidths : dump;
	unsigned [1] widthOfLengths : dump;
	unsigned [2] octetNrOfStartGroup : dump;
	if (twoOrdersOfSPD) {
		unsigned [1] widthOfSpatialDifferencingDescriptors : dump;
	} else {
		transient widthOfSpatialDifferencingDescriptors = -1;
	}
}

position offsetBeforeData;

if(bitmapPresent)   {
   meta codedValues data_2order_packing(
     section4Length,
     offsetBeforeData,
     offsetSection4,

     bitsPerValue,
     referenceValue,
     binaryScaleFactor,
     decimalScaleFactor,

     halfByte,
     N1,
     N2,
     numberOfFirstOrderPackedValues,
     extraValues,
     numberOfSecondOrderPackedValues,

     matrixOfValues,
     secondaryBitmapPresent,
     secondOrderOfDifferentWidth,

     generalExtended2ordr      ,
     boustrophedonicOrdering   ,
     twoOrdersOfSPD            ,
     plusOneinOrdersOfSPD      ,

     widthOfWidths,
     widthOfLengths,
     octetNrOfStartGroup,
     widthOfSpatialDifferencingDescriptors,

     Ni,
     bitmap

   ): read_only;
   alias data.packedValues = codedValues; 

   meta values data_apply_bitmap(codedValues,bitmap,missingValue,binaryScaleFactor) : dump;
} else {
   meta values data_2order_packing(
    section4Length,
    offsetBeforeData,
    offsetSection4,

    bitsPerValue,
    referenceValue,
    binaryScaleFactor,
    decimalScaleFactor,
    halfByte,

    N1,
    N2,
    numberOfFirstOrderPackedValues,
    extraValues,
    numberOfSecondOrderPackedValues,

    matrixOfValues,
    secondaryBitmapPresent,
    secondOrderOfDifferentWidth,


    generalExtended2ordr      ,
    boustrophedonicOrdering   ,
    twoOrdersOfSPD            ,
    plusOneinOrdersOfSPD      ,

    widthOfWidths,
    widthOfLengths,
    octetNrOfStartGroup,
    widthOfSpatialDifferencingDescriptors,

    Ni,
    bitmap
   ) : dump;
   alias data.packedValues = values;
}

#transient numberOfCodedValues
#     =numberOfFirstOrderPackedValues+numberOfSecondOrderPackedValues;


meta numberOfCodedValues data_2order_packing_count(offsetSection4,numberOfFirstOrderPackedValues, 
               twoOrdersOfSPD, plusOneinOrdersOfSPD,widthOfLengths, octetNrOfStartGroup);

template statistics "common/statistics_grid.def";
